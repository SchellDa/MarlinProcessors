#include "reftrackalignprocessor.h"
#include <iostream>
#include <fstream>
#include <memory>
#include "mymemory"

#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <EVENT/TrackerPulse.h>
#include <EVENT/TrackerData.h>
#include <EVENT/Track.h>
#include <UTIL/LCTime.h>
#include <UTIL/CellIDDecoder.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCRunHeaderImpl.h>
#include <IMPL/LCEventImpl.h>
#include <IMPL/TrackerDataImpl.h>
#include <EUTelAlignmentConstant.h>
#include <EUTelSparseClusterImpl.h>
// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"
#include "marlin/Global.h"

#include <gear/GearMgr.h>

#include <TProfile.h>
#include <TFitResult.h>

#ifdef MARLIN_USE_AIDA
#include <AIDA/ITree.h>
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>
#include <AIDA/IAxis.h>
//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

using namespace lcio;
using namespace marlin;
using namespace eutelescope;

RefTrackAlignProcessor aRefTrackAlignProcessor;


RefTrackAlignProcessor::RefTrackAlignProcessor()
 : Processor("RefTrackAlignProcessor"),
 _colRefData(""), _colTracks(""), _refAlignDB(""), _refCutDB(""),
 _flipXCoordinate(false), _flipYCoordinate(true), _refSensorId(8),
 _siPlanesParameters(nullptr), _siPlanesLayerLayout(nullptr), _totalEvents(0),
 _validEvents(0), _refTrackExtrapolatedXCor(nullptr), _refTrackExtrapolatedYCor(nullptr)
{
	_description = "Calculate REF offset-alignment using fitted Tracks.";
	streamlog_out(DEBUG) << "RefTrackAlignProcessor constructor called. Wow." << std::endl;

	// register steering parameters: name, description, class-variable, default value
	registerInputCollection(
		LCIO::TRACKERDATA,
        	"RefDataCollectionName", 
		"Name of the collection containing REF TrackerData",
		_colRefData,
		std::string("CMSPixelREF")
		);
	registerInputCollection(
		LCIO::TRACK,
		"TrackCollectionName",
		"Collection containing fitted and aligned Tracks through telescope.",
		_colTracks,
		std::string("track")
		);
	registerProcessorParameter(
		"refAlignDbFileName",
		"File name of the align-DB generated by this processor. Add .slcio",
		_refAlignDB,
		std::string("ref-align-db.slcio")
		);
	registerProcessorParameter(
		"flipXCoordinate",
		"Wether or not to flip the X coordinate of the REF hits",
		_flipXCoordinate,
		_flipXCoordinate
		);
	registerProcessorParameter(
		"cutDbFileName",
		"File name of the cut information file. Add .csv",
		_refCutDB,
		std::string("ref-cut-db.csv")
		);
	registerProcessorParameter(
		"flipYCoordinate",
		"Wether or not to flip the Y coordinate of the REF hits",
		_flipYCoordinate,
		_flipYCoordinate
		);
	registerOptionalParameter(
		"refSensorId",
		"Sensor ID of the reference plane specified in the GEAR file.",
		_refSensorId,
		_refSensorId
		);
}

void RefTrackAlignProcessor::init()
{
	streamlog_out(DEBUG) << "   init called  " << std::endl;

	// usually a good idea to
	printParameters();

	_siPlanesParameters = &Global::GEAR->getSiPlanesParameters();
	_siPlanesLayerLayout = &_siPlanesParameters->getSiPlanesLayerLayout();
#ifdef DEBUG
	std::ofstream fout("test.csv");
#endif
	bookHistos();
}


void RefTrackAlignProcessor::processRunHeader(LCRunHeader* run)
{
	_refTrackExtrapolatedXCor = new TH2D("ExtrapolatedXCor", "REF <-> extrap. Track X Correlation",
		52, -5, 5, 300, -15, 15);
	_refTrackExtrapolatedYCor = new TH2D("ExtrapolatedYCor", "REF <-> extrap. Track Y Correlation",
		80, -5, 5, 300, -8, 6);	
	_xCorHist = new TH1D("xCorHist", "X Correlation Histogram", 1000, -20, 20);
	_yCorHist = new TH1D("yCorHist", "Y Correlation Histogram", 1000, -20, 20);
	// _refTrackExtrapolatedXCor->SetDirectory(nullptr);	
	// _refTrackExtrapolatedYCor->SetDirectory(nullptr);	
} 

void RefTrackAlignProcessor::processEvent(LCEvent* evt)
{
	_totalEvents++;
	LCCollection* colRefData = nullptr;
	LCCollection* colTracks = nullptr;
	try {
		colRefData = evt->getCollection(_colRefData);
	} catch(lcio::DataNotAvailableException& e) {
		// streamlog_out(WARNING) << e.what() << std::endl;
	}
	try {
		colTracks = evt->getCollection(_colTracks);
	} catch(lcio::DataNotAvailableException& e) {
		// streamlog_out(WARNING) << e.what() << std::endl;
	}
	// one or more input colletions not found in Event! Aborting...
	if(!colRefData || !colTracks) {
		// streamlog_out(ERROR) << "One or more input collections not found!" << std::endl;
		return;
	}
	_validEvents++;
	//---------------------------------------------------------------------------
	//       Read raw pulses in REF and transform to global coordinates
	//---------------------------------------------------------------------------
	auto local_hits = getRefHits(colRefData);
	auto global_hits = transformRefHits(local_hits);
	auto tracks = getTracksFromCollection(evt, colTracks);
#if defined(USE_AIDA) || defined(MARLIN_USE_AIDA)
	for(auto& ref: local_hits) {
		for(auto& track: tracks) {
			refTrackXCorrelation->fill(ref(0), track.fitted[5](0));
			refTrackYCorrelation->fill(ref(1), track.fitted[5](1));
		}
	}
#endif

	// Debugging output...
#ifdef DEBUG
	std::ofstream fout("debug_refalign.csv", std::ofstream::app);
	if(tracks.size() == 0 || global_hits.size() == 0) {
		fout << "0 0 0 " << evt->getEventNumber() << " # NO HIT\n";
	} else {
		int hitNo = 0;
		for(const auto& hit: global_hits) {
			fout << hit(0) << " " << hit(1) << " " << hit(2) << " " << evt->getEventNumber() << " " << hitNo << " " << "8" << "\n";
			hitNo++;
		}
		int trackNo = 0;
		for(const auto& track: tracks) {
			for(size_t i=0; i<track.fitted.size(); i++) {
				auto pos = track.fitted[i];
				auto sensor = track.fittedSensor[i];
				fout << pos(0) << " " << pos(1) << " " << pos(2) << " " << track.eventNumber << " " << trackNo << " " << sensor << "\n";
			}
			trackNo++;
		}
	}
	fout << "\n" << std::endl;
#endif

/*	// Only support one global hit
	if(global_hits.size() != 1) {
		return;
	}
	int nearest_idx = -1;
	int idx = 0;
	double distance_sqr = 0.0f;
	auto hit = global_hits[0];
	for(auto& track: tracks) {
		assert(track.fitted.size() == 6);
		auto dsp = track.fitted[5]; // down-stream point
		auto dist = hit.dot(dsp);
		if(dist < distance_sqr || nearest_idx == -1) {
			distance_sqr = dist;
			nearest_idx = idx;
		}
		idx++;
	}*/
	for(auto& hit: global_hits) {
		for(auto& track: tracks) {
			// extrapolate track onto 2d REF layer
			auto base = track.fitted[0];
			auto dir = track.fitted[2] - track.fitted[0];
			auto t = (hit(2) - base(2)) / dir(2);
			auto hit_extrapolated = base + t*dir;
			refTrackGlobalXCor->fill(hit(0), hit_extrapolated(0));
			refTrackGlobalYCor->fill(hit(1), hit_extrapolated(1));
			_refTrackExtrapolatedXCor->Fill(hit(0), hit_extrapolated(0));
			_refTrackExtrapolatedYCor->Fill(hit(1), hit_extrapolated(1));
			_xCorHist->Fill(hit(0) - hit_extrapolated(0));
			_yCorHist->Fill(hit(1) - hit_extrapolated(1));
		}
	}
}

void RefTrackAlignProcessor::check( LCEvent * evt )
{
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}

void RefTrackAlignProcessor::end()
{
	/////
	// OUTDATED Get REF alignment by applying cut on track correlation histograms and
	// fitting the resulting diagonal.
/*	cutCorrelationHistogram(_refTrackExtrapolatedXCor, refTrackGlobalXProfile);
	cutCorrelationHistogram(_refTrackExtrapolatedYCor, refTrackGlobalYProfile);
	auto profileX = _refTrackExtrapolatedXCor->ProfileX();
	auto profileY = _refTrackExtrapolatedYCor->ProfileX();
	auto resultX = profileX->Fit("pol1", "FSM");
	auto resultY = profileY->Fit("pol1", "FSM");*/

	///////
	// Get REF alignment offsets by fitting a gaussian to xCorHist and yCorHist.
	// The mean is the offset; sigma is used to define the data cut.
	std::vector<Double_t> x_centers(_xCorHist->GetNbinsX());
	_xCorHist->GetCenter(&x_centers[0]);
	std::vector<Double_t> y_centers(_yCorHist->GetNbinsX());
	_yCorHist->GetCenter(&y_centers[0]);
	auto x_max_loc = x_centers[_xCorHist->GetMaximumBin()];
	auto y_max_loc = y_centers[_yCorHist->GetMaximumBin()];
	auto resultX = _xCorHist->Fit("gaus", "FSMR", "", x_max_loc - _xCorHist->GetRMS()/2,
			x_max_loc + _xCorHist->GetRMS()/2);
	auto resultY = _yCorHist->Fit("gaus", "FSMR", "", y_max_loc - _yCorHist->GetRMS()/2,
			y_max_loc + _yCorHist->GetRMS()/2);
	Eigen::Array2d offset(resultX->Parameter(1), resultY->Parameter(1));
	Eigen::Array2d offsetError(resultX->Error(1), resultY->Error(1));
	Eigen::Array2d sigma(resultY->Parameter(2), resultY->Parameter(2));
	Eigen::Array2d sigmaError(resultY->Error(2), resultY->Error(2));
	
	streamlog_out(MESSAGE) << "Alignment results:\n"
	<< "\tOffset " << offset(0) << "+/-" << offsetError(0) << "  " << offset(1) << "+/-" << offsetError(1)
	<< "\n\tsigma " << sigma(0) << "+/-" << sigmaError(0) << "  " << sigma(1) << "+/-" << sigmaError(1)
	<< std::endl;

	streamlog_out(MESSAGE) << "Write cut information to " << _refCutDB << std::endl;
	std::ofstream of(_refCutDB);
	of << "# MeanX\tMeanY\tSigmaX\tSigmaY\n"
		<< offset(0) << " " << offset(1) << " " << sigma(0) << " " << sigma(1) << std::endl;
	of.close();

	streamlog_out(DEBUG) << "Write alignment DB to " << _refAlignDB << std::endl;
	// Try to open alignment DB file
	auto writer = LCFactory::getInstance()->createLCWriter();
	try {
		writer->open(_refAlignDB, LCIO::WRITE_NEW);
	} catch(std::exception& e) {
		streamlog_out(ERROR4) << "Cannot write alignment DB: " << e.what() << std::endl;
		throw;
	}
	try {
		// Write run header and create a single event
		auto lcHeader = std::make_unique<LCRunHeaderImpl>();
		lcHeader->setRunNumber(0);		
		writer->writeRunHeader(lcHeader.get());
		auto evt = std::make_unique<LCEventImpl>();
		auto now = new UTIL::LCTime;
		evt->setTimeStamp(now->timeStamp());
		delete now;
		evt->setRunNumber(0);
		evt->setEventNumber(0);
		// Create the alignment constant collection
		auto  col = new LCCollectionVec(LCIO::LCGENERICOBJECT);
		// Create and populate alignment constant object
		auto alignment = new EUTelAlignmentConstant();
		/// @TODO fill generated data
		alignment->setSensorID(8);
		alignment->setXOffset(offset(0));
		alignment->setYOffset(offset(1));
		alignment->setXOffsetError(offsetError(0));
		alignment->setYOffsetError(offsetError(1));
		col->push_back(alignment);
		// Merge collection to event and write to DB
		evt->addCollection(col, std::string("alignment"));
		writer->writeEvent(evt.get());
	} catch(std::exception& e) {
		writer->close();
		throw;
	}
}

std::vector<Eigen::Vector2d> RefTrackAlignProcessor::getRefHits(LCCollection* collection)
{
	std::vector<Eigen::Vector2d> hits;
	try {
		CellIDDecoder<TrackerDataImpl> cellDecoder(collection);
		assert(collection->getNumberOfElements() == 1);
		auto data = dynamic_cast<TrackerDataImpl*>(collection->getElementAt(0));
		auto type = static_cast<SparsePixelType>(static_cast<int>(cellDecoder(data)["sparsePixelType"]));
		assert(type == kEUTelGenericSparsePixel);
		auto sparseData = std::make_unique<EUTelTrackerDataInterfacerImpl<EUTelGenericSparsePixel>>(data);
		auto sparsePixel = std::make_unique<EUTelGenericSparsePixel>();
		for(size_t i=0; i < sparseData->size(); i++) {
			sparseData->getSparsePixelAt(i, sparsePixel.get());
			hits.push_back(Eigen::Vector2d{sparsePixel->getXCoord(), sparsePixel->getYCoord()});
		}
	} catch(const std::exception& e) {
		streamlog_out(WARNING) << "getRefHits(): " << e.what() << std::endl;
	}
	return hits;
}

std::vector<Eigen::Vector3d> RefTrackAlignProcessor::transformRefHits(std::vector<Eigen::Vector2d> hits)
{
	std::vector<Eigen::Vector3d> transformed;
	// "alias" to make code more readable
	auto layers = _siPlanesLayerLayout;
	int refIdx = -1;
	for(int i=0; i<layers->getNLayers(); i++) {
		auto id = layers->getID(i);
		if(id == _refSensorId) {
			refIdx = i;
			break;
		}
	}
	if(refIdx == -1) {
		streamlog_out(ERROR4) << "Did not find REF in GEAR file with sensor ID "
				      << _refSensorId << std::endl;
		exit(-1);
	}
	Eigen::Vector3d layer_offset(
		layers->getLayerPositionX(refIdx),
		layers->getLayerPositionY(refIdx),
		layers->getLayerPositionZ(refIdx));
	/// \todo these are usually zero in our GEAR files, so we ignore them for now...
	auto layer_alpha = layers->getLayerRotationZY(refIdx); // around X
	auto layer_beta = layers->getLayerRotationZX(refIdx); // around Y
	auto layer_gamma = layers->getLayerRotationXY(refIdx); // around Z
	Eigen::Matrix3d layer_rot(Eigen::Matrix3d::Identity());

	Eigen::Vector3d sensitive_offset(
		layers->getSensitivePositionX(refIdx),
		layers->getSensitivePositionY(refIdx),
		layers->getSensitivePositionZ(refIdx));
	Eigen::Matrix2d sensitive_rot;
	sensitive_rot << layers->getSensitiveRotation1(refIdx),
			 layers->getSensitiveRotation2(refIdx),
			 layers->getSensitiveRotation3(refIdx),
			 layers->getSensitiveRotation4(refIdx);
	Eigen::Array2d sensitive_size(
		layers->getSensitiveSizeX(refIdx),
		layers->getSensitiveSizeY(refIdx));
	Eigen::Array2i sensitive_npix(
		layers->getSensitiveNpixelX(refIdx),
		layers->getSensitiveNpixelY(refIdx));
	auto sensitive_pitch = sensitive_size / sensitive_npix.cast<double>();
	for(const auto& hit: hits) {
		auto l_hit = sensitive_rot * (hit.array()*sensitive_pitch - sensitive_size/2).matrix();
		Eigen::Vector3d l_hit2 = {l_hit[0], l_hit[1], 0};
		l_hit2 += sensitive_offset;
		if(_flipXCoordinate) l_hit2(0) *= -1;
		if(_flipYCoordinate) l_hit2(1) *= -1;
		transformed.push_back(l_hit2);
	}
	return transformed;
}

std::vector<RefTrackAlignProcessor::track_t> RefTrackAlignProcessor::getTracksFromCollection(LCEvent* evt, LCCollection* col)
{
	std::vector<track_t> tracks;
	for(int i=0; i < col->getNumberOfElements(); i++) {
		auto track = dynamic_cast<EVENT::Track*>(col->getElementAt(i));
		assert(track != nullptr);
		auto decoder = CellIDDecoder<TrackerHit>(EUTELESCOPE::HITENCODING);
		track_t new_track;
		new_track.eventNumber = evt->getEventNumber();
		new_track.trackNumber = i;
		for(auto hit: track->getTrackerHits()) {
			auto pos = hit->getPosition();
			Eigen::Vector3d posVec(pos[0], pos[1], pos[2]);
			auto properties = decoder(hit)["properties"];
			auto sensor = decoder(hit)["sensorID"];
			bool fitted = (properties&kFittedHit) > 0;
			if(fitted) {
				new_track.fitted.push_back(posVec);
				new_track.fittedSensor.push_back(sensor);
			} else {
				new_track.raw.push_back(posVec);
				new_track.rawSensor.push_back(sensor);
			}	
		}
		tracks.push_back(new_track);
	}
	return tracks;
}

void RefTrackAlignProcessor::bookHistos()
{
#if defined(USE_AIDA) || defined(MARLIN_USE_AIDA)
	AIDAProcessor::tree(this)->mkdir("Transformation");
	refTrackXCorrelation = AIDAProcessor::histogramFactory(this)->
		createHistogram2D("refTrackXCorrelation", 52, 0, 52, 300, -15, 15);
	refTrackYCorrelation = AIDAProcessor::histogramFactory(this)->
		createHistogram2D("refTrackYCorrelation", 80, 0, 80, 300, -8, 6);
	refTrackGlobalXCor = AIDAProcessor::histogramFactory(this)->
		createHistogram2D("refTrackGlobalXCor", 52, -15, 15, 300, -15, 15);
	refTrackGlobalYCor = AIDAProcessor::histogramFactory(this)->
		createHistogram2D("refTrackGlobalYCor", 80, -8, 6, 300, -8, 6);
	refTrackGlobalXProfile = AIDAProcessor::histogramFactory(this)->
		createProfile1D("refTrackGlobalXProfile", 52, -5, 5);
	refTrackGlobalYProfile = AIDAProcessor::histogramFactory(this)->
		createProfile1D("refTrackGlobalYProfile", 80, -9, 9);
#endif
}

void RefTrackAlignProcessor::cutCorrelationHistogram(TH2D* hist, AIDA::IProfile1D* debugProfile)
{
	std::vector<Double_t> x_centers(hist->GetXaxis()->GetNbins());
	hist->GetXaxis()->GetCenter(&x_centers[0]);
	std::vector<Double_t> y_centers(hist->GetYaxis()->GetNbins());
	hist->GetYaxis()->GetCenter(&y_centers[0]);
	double threshold = hist->GetMaximum() * 0.1;
	for(int ix=0; ix < hist->GetNbinsX(); ix++) {
		for(int iy=0; iy < hist->GetNbinsY(); iy++) {
			auto val = hist->GetBinContent(ix, iy);
			if(val < threshold)
				hist->SetBinContent(ix, iy, 0);
#if defined(USE_AIDA) || defined(MARLIN_USE_AIDA)
			else
				debugProfile->fill(x_centers[ix], y_centers[iy], val);
#endif
			
		}
	}
}

