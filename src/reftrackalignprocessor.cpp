#include "reftrackalignprocessor.h"
#include <iostream>
#include <fstream>
#include <memory>
#include "mymemory"

#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <EVENT/TrackerPulse.h>
#include <EVENT/TrackerData.h>
#include <UTIL/LCTime.h>
#include <UTIL/CellIDDecoder.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCRunHeaderImpl.h>
#include <IMPL/LCEventImpl.h>
#include <IMPL/TrackerDataImpl.h>
#include <EUTelAlignmentConstant.h>
#include <EUTelSparseClusterImpl.h>
// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"
#include "marlin/Global.h"

#include <gear/GearMgr.h>

#ifdef MARLIN_USE_AIDA
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>
//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

using namespace lcio;
using namespace marlin;
using namespace eutelescope;

RefTrackAlignProcessor aRefTrackAlignProcessor;


RefTrackAlignProcessor::RefTrackAlignProcessor()
 : Processor("RefTrackAlignProcessor"),
 _colRefData(""), _colTracks(""), _refAlignDB(""), _refSensorId(8),
 _siPlanesParameters(nullptr), _siPlanesLayerLayout(nullptr), _totalEvents(0),
 _validEvents(0)
{
	_description = "Calculate REF offset-alignment using fitted Tracks.";
	streamlog_out(DEBUG) << "RefTrackAlignProcessor constructor called. Wow." << std::endl;

	// register steering parameters: name, description, class-variable, default value
	registerInputCollection(
		LCIO::TRACKERDATA,
        	"RefDataCollectionName", 
		"Name of the collection containing REF TrackerData",
		_colRefData,
		std::string("CMSPixelREF")
		);
	registerInputCollection(
		LCIO::TRACK,
		"TrackCollectionName",
		"Collection containing fitted and aligned Tracks through telescope.",
		_colTracks,
		std::string("track")
		);
	registerProcessorParameter(
		"refAlignDbFileName",
		"File name of the align-DB generated by this processor",
		_refAlignDB,
		std::string("ref-align-db.slcio")
		);
	registerOptionalParameter(
		"refSensorId",
		"Sensor ID of the reference plane specified in the GEAR file.",
		_refSensorId,
		_refSensorId
		);
}

void RefTrackAlignProcessor::init()
{
	streamlog_out(DEBUG) << "   init called  " << std::endl;

	// usually a good idea to
	printParameters();
	
	_siPlanesParameters = &Global::GEAR->getSiPlanesParameters();
	_siPlanesLayerLayout = &_siPlanesParameters->getSiPlanesLayerLayout();
}


void RefTrackAlignProcessor::processRunHeader(LCRunHeader* run)
{
} 

void RefTrackAlignProcessor::processEvent(LCEvent* evt)
{
	_totalEvents++;
	LCCollection* colRefData = nullptr;
	LCCollection* colTracks = nullptr;
	try {
		colRefData = evt->getCollection(_colRefData);
	} catch(lcio::DataNotAvailableException& e) {
		// streamlog_out(WARNING) << e.what() << std::endl;
	}
	try {
		colTracks = evt->getCollection(_colTracks);
	} catch(lcio::DataNotAvailableException& e) {
		// streamlog_out(WARNING) << e.what() << std::endl;
	}
	// one or more input colletions not found in Event! Aborting...
	if(!colRefData || !colTracks) {
		// streamlog_out(ERROR) << "One or more input collections not found!" << std::endl;
		return;
	}
	_validEvents++;
	//---------------------------------------------------------------------------
	//       Read raw pulses in REF and transform to global coordinates
	//---------------------------------------------------------------------------
	auto local_hits = getRefHits(colRefData);
	auto global_hits = transformRefHits(local_hits);
}

/*
void RefTrackAlignProcessor::processEvent( LCEvent * evt )
{
    // this gets called for every event 
    // usually the working horse ...


#ifdef MARLIN_USE_AIDA

    // define a histogram pointer
    static AIDA::ICloud1D* hMCPEnergy ;    

    if( isFirstEvent() ) { 

        hMCPEnergy = AIDAProcessor::histogramFactory(this)->
            createCloud1D( "hMCPEnergy", "energy of the MCParticles", 100 ) ; 

    }
#endif // MARLIN_USE_AIDA

   // try to get lcio collection (exits if collection is not available)::
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    LCCollection* col = evt->getCollection(_colRefData);


    // Alternativelly if you do not want Marlin to exit in case of a non-existing collection
    // use the following (commented out) code:
    //LCCollection* col = NULL;
    //try{
    //    col = evt->getCollection( _colName );
    //}
    //catch( lcio::DataNotAvailableException e )
    //{
    //    streamlog_out(WARNING) << _colName << " collection not available" << std::endl;
    //    col = NULL;
    //}

    // this will only be entered if the collection is available
    if( col != NULL ){

        int nMCP = col->getNumberOfElements()  ;

        for(int i=0; i< nMCP ; i++){

            MCParticle* p = dynamic_cast<MCParticle*>( col->getElementAt( i ) ) ;

#ifdef MARLIN_USE_AIDA
            // fill histogram from LCIO data :
            hMCPEnergy->fill( p->getEnergy() ) ;
#endif
        } 
    }



    //-- note: this will not be printed if compiled w/o MARLINDEBUG=1 !

    streamlog_out(DEBUG) << "   processing event: " << evt->getEventNumber() 
        << "   in run:  " << evt->getRunNumber() << std::endl ;
}
*/


void RefTrackAlignProcessor::check( LCEvent * evt )
{
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void RefTrackAlignProcessor::end()
{
	streamlog_out(MESSAGE4) << "Total number of events processed: " << _totalEvents << "\n"
		                << "                    valid events: " << _validEvents << std::endl;
	streamlog_out(DEBUG) << "Write alignment DB to " << _refAlignDB << std::endl;
	// Try to open alignment DB file
	auto writer = LCFactory::getInstance()->createLCWriter();
	try {
		writer->open(_refAlignDB, LCIO::WRITE_NEW);
	} catch(std::exception& e) {
		streamlog_out(ERROR4) << "Cannot write alignment DB: " << e.what() << std::endl;
		throw;
	}
	try {
		// Write run header and create a single event
		auto lcHeader = std::make_unique<LCRunHeaderImpl>();
		lcHeader->setRunNumber(0);		
		writer->writeRunHeader(lcHeader.get());
		auto evt = std::make_unique<LCEventImpl>();
		auto now = new UTIL::LCTime;
		evt->setTimeStamp(now->timeStamp());
		delete now;
		evt->setRunNumber(0);
		evt->setEventNumber(0);
		// Create the alignment constant collection
		auto  col = new LCCollectionVec(LCIO::LCGENERICOBJECT);
		// Create and populate alignment constant object
		auto alignment = new EUTelAlignmentConstant();
		/// @TODO fill generated data
		alignment->setSensorID(8);
		alignment->setXOffset(0.1);
		alignment->setYOffset(0.5);
		alignment->setZOffset(0.001);
		col->push_back(alignment);
		// Merge collection to event and write to DB
		evt->addCollection(col, std::string("alignment"));
		writer->writeEvent(evt.get());
	} catch(std::exception& e) {
		writer->close();
		throw;
	}
}

std::vector<Eigen::Vector2d> RefTrackAlignProcessor::getRefHits(LCCollection* collection)
{
	std::vector<Eigen::Vector2d> hits;
	try {
		CellIDDecoder<TrackerDataImpl> cellDecoder(collection);
		assert(collection->getNumberOfElements() == 1);
		auto data = dynamic_cast<TrackerDataImpl*>(collection->getElementAt(0));
		auto type = static_cast<SparsePixelType>(static_cast<int>(cellDecoder(data)["sparsePixelType"]));
		assert(type == kEUTelGenericSparsePixel);
		auto sparseData = std::make_unique<EUTelTrackerDataInterfacerImpl<EUTelGenericSparsePixel>>(data);
		auto sparsePixel = std::make_unique<EUTelGenericSparsePixel>();
		for(size_t i=0; i < sparseData->size(); i++) {
			sparseData->getSparsePixelAt(i, sparsePixel.get());
			hits.push_back(Eigen::Vector2d{sparsePixel->getXCoord(), sparsePixel->getYCoord()});
		}
	} catch(const std::exception& e) {
		streamlog_out(WARNING) << "getRefHits(): " << e.what() << std::endl;
	}
	return hits;
}

std::vector<Eigen::Vector3d> RefTrackAlignProcessor::transformRefHits(std::vector<Eigen::Vector2d> hits)
{
	std::vector<Eigen::Vector3d> transformed;
	// "alias" to make code more readable
	auto layers = _siPlanesLayerLayout;
	int refIdx = -1;
	for(int i=0; i<layers->getNLayers(); i++) {
		auto id = layers->getID(i);
		if(id == _refSensorId) {
			refIdx = i;
			break;
		}
	}
	if(refIdx == -1) {
		streamlog_out(ERROR4) << "Did not find REF in GEAR file with sensor ID "
				      << _refSensorId << std::endl;
		exit(-1);
	}
	Eigen::Vector3d layer_offset(
		layers->getLayerPositionX(refIdx),
		layers->getLayerPositionY(refIdx),
		layers->getLayerPositionZ(refIdx));
	/// \todo these are usually zero in our GEAR files, so we ignore them for now...
	auto layer_alpha = layers->getLayerRotationZY(refIdx); // around X
	auto layer_beta = layers->getLayerRotationZX(refIdx); // around Y
	auto layer_gamma = layers->getLayerRotationXY(refIdx); // around Z
	Eigen::Matrix3d layer_rot(Eigen::Matrix3d::Identity());

	Eigen::Vector3d sensitive_offset(
		layers->getSensitivePositionX(refIdx),
		layers->getSensitivePositionY(refIdx),
		layers->getSensitivePositionZ(refIdx));
	Eigen::Matrix2d sensitive_rot;
	sensitive_rot << layers->getSensitiveRotation1(refIdx),
			 layers->getSensitiveRotation2(refIdx),
			 layers->getSensitiveRotation3(refIdx),
			 layers->getSensitiveRotation4(refIdx);
	Eigen::Array2d sensitive_size(
		layers->getSensitiveSizeX(refIdx),
		layers->getSensitiveSizeY(refIdx));
	Eigen::Array2i sensitive_npix(
		layers->getSensitiveNpixelX(refIdx),
		layers->getSensitiveNpixelY(refIdx));
	auto sensitive_pitch = sensitive_size / sensitive_npix.cast<double>();
	std::ofstream fout("test.csv", std::ofstream::app);
	for(const auto& hit: hits) {
		auto l_hit = sensitive_rot * (hit.array()*sensitive_pitch).matrix();
		Eigen::Vector3d l_hit2 = {l_hit[0], l_hit[1], 0};
		l_hit2 += sensitive_offset;
		transformed.push_back(l_hit2);
		fout << l_hit2(0) << " " << l_hit2(1) << " " << l_hit2(2) << "\n";
	}
	fout << "\n" << std::endl;
		
	return transformed;
}


