#include "reftransformprocessor.h"
#include <iostream>
#include <fstream>
#include <memory>
#include "mymemory"

#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <EVENT/TrackerPulse.h>
#include <EVENT/TrackerData.h>
#include <EVENT/Track.h>
#include <UTIL/LCTime.h>
#include <UTIL/CellIDDecoder.h>
#include <UTIL/CellIDEncoder.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCRunHeaderImpl.h>
#include <IMPL/LCEventImpl.h>
#include <IMPL/TrackerDataImpl.h>
#include <IMPL/TrackerHitImpl.h>
#include <EUTelAlignmentConstant.h>
#include <EUTelSparseClusterImpl.h>
// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"
#include "marlin/Global.h"

#include <gear/GearMgr.h>

#include <TProfile.h>
#include <TFitResult.h>

#ifdef MARLIN_USE_AIDA
#include <AIDA/ITree.h>
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>
#include <AIDA/IAxis.h>
//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

using namespace lcio;
using namespace marlin;
using namespace eutelescope;

RefTransformProcessor aRefTransformProcessor;


RefTransformProcessor::RefTransformProcessor()
 : Processor("RefTransformProcessor"),
 _colRefData(""), _refAlignDB(""), _refCutDB(""), _colTracks(""), _colTransformedRefData(""),
 _csvOutputFile("transformed.csv"), _csvOutputFileEnable(true), _cutWidthTimesSigma(2), _flipXCoordinate(false), _flipYCoordinate(true), _refSensorId(8),
 _debugCsvOutput(false), _debugCsvOutputFile("tracktransform.csv"), 
 _siPlanesParameters(nullptr), _siPlanesLayerLayout(nullptr)
{
	_description = "Transform REF hits to global coordinate system, cut uncorrelated events and apply alignment.";

	// register steering parameters: name, description, class-variable, default value
	registerInputCollection(
		LCIO::TRACKERDATA,
        	"RefDataCollectionName", 
		"Name of the collection containing REF TrackerData",
		_colRefData,
		std::string("CMSPixelREF")
		);
	registerInputCollection(
		LCIO::TRACK,
		"TrackCollectionName",
		"Collection containing fitted and aligned Tracks through telescope.",
		_colTracks,
		std::string("track")
		);
	registerOutputCollection(
		LCIO::TRACKERHIT,
		"TransformedRefDataCollectionName",
		"Name of the output collection for the transformed and cut ref data",
		_colTransformedRefData,
		std::string("refhit")
		);
/*	registerOutputCollection(
		LCIO::TRACK,
		"FilteredTrackCollectionName",
		"Name of the collection where tracks hitting the REF are saved.",
		_colFilteredTracks,
		std::string("reftracks")
		);*/
	registerProcessorParameter(
		"csvOutputFilename",
		"Name of the clear-text CSV output file",
		_csvOutputFile,
		_csvOutputFile
		);
	registerProcessorParameter(
		"csvOutputEnable",
		"Enable clear text CSV output",
		_csvOutputFileEnable,
		_csvOutputFileEnable
		);
	registerProcessorParameter(
		"refAlignDbFileName",
		"File name of the align-DB generated by this processor. Add .slcio",
		_refAlignDB,
		std::string("ref-align-db.slcio")
		);
	registerProcessorParameter(
		"cutWidthTimesSigma",
		"Width of the inclusion zone for cutting uncorrelated events in multiples of sigma.",
		_cutWidthTimesSigma,
		_cutWidthTimesSigma
		);
	registerProcessorParameter(
		"cutDbFileName",
		"File name of the cut information file. Add .csv",
		_refCutDB,
		std::string("ref-cut-db.csv")
		);
	registerProcessorParameter(
		"flipXCoordinate",
		"Wether or not to flip the X coordinate of the REF hits",
		_flipXCoordinate,
		_flipXCoordinate
		);
	registerProcessorParameter(
		"flipYCoordinate",
		"Wether or not to flip the Y coordinate of the REF hits",
		_flipYCoordinate,
		_flipYCoordinate
		);
	registerOptionalParameter(
		"refSensorId",
		"Sensor ID of the reference plane specified in the GEAR file.",
		_refSensorId,
		_refSensorId
		);
	registerOptionalParameter(
		"debugCsvOutput",
		"Enable debugging output with plain CSV files.",
		_debugCsvOutput,
		_debugCsvOutput
		);
	registerOptionalParameter(
		"debugCsvOutputFile",
		"Output file for plain text CSV debugging output",
		_debugCsvOutputFile,
		_debugCsvOutputFile
		);
	registerProcessorParameter(
		"swapRefAxis",
		"Swap the X and Y coordinates of the REF hits.",
		_swapRefAxis,
		_swapRefAxis
		);
}

void RefTransformProcessor::init()
{
	streamlog_out(DEBUG) << "   init called  " << std::endl;

	// usually a good idea to
	printParameters();

	_siPlanesParameters = &Global::GEAR->getSiPlanesParameters();
	_siPlanesLayerLayout = &_siPlanesParameters->getSiPlanesLayerLayout();
	bookHistos();

	std::ifstream fin(_refCutDB);
	std::string line;
	while(!fin.eof()) {
		std::getline(fin, line);
		if(line.length() == 0) continue;
		if(line[0] == '#') continue;
		std::istringstream stream(line);
		stream >> _cutData.meanX >> _cutData.meanY >> _cutData.sigmaX >> _cutData.sigmaY;	
	}
	streamlog_out(DEBUG) << "Cut data: "
		<< _cutData.meanX << " "
		<< _cutData.meanY << " "
		<< _cutData.sigmaX << " "
		<< _cutData.sigmaY << std::endl;
	if(_debugCsvOutput) {
		// clear existing debug output file and write header
		std::ofstream of(_debugCsvOutputFile);
		try {
			of.exceptions(of.failbit);
		} catch(const std::exception& e) {
			streamlog_out(ERROR) << "Cannot open debug output CSV file '" << _debugCsvOutput
			                     << "'. Reason: " << e.what() << std::endl;
			throw;
		}
		of << "# X\tY\tZ\tEvt\tRun\tDummy\n";
		of.close();
	}
	if(_csvOutputFileEnable) {
		// clear existing debug output file and write header
		std::ofstream of(_csvOutputFile);
		try {
			of.exceptions(of.failbit);
		} catch(const std::exception& e) {
			streamlog_out(ERROR) << "Cannot open CSV output file '" << _csvOutputFile
			                     << "'. Reason: " << e.what() << std::endl;
			throw;
		}
		of << "# X\tY\tZ\tSensorID\tEvt\tRun\n";
		of.close();
	}
}


void RefTransformProcessor::processRunHeader(LCRunHeader* run)
{
} 

void RefTransformProcessor::processEvent(LCEvent* evt)
{
	LCCollection* colRefData = nullptr;
	LCCollection* colTracks = nullptr;
	try {
		colRefData = evt->getCollection(_colRefData);
	} catch(lcio::DataNotAvailableException& e) {
		//streamlog_out(WARNING) << e.what() << std::endl;
	}
	try {
		colTracks = evt->getCollection(_colTracks);
	} catch(lcio::DataNotAvailableException& e) {
		//streamlog_out(WARNING) << e.what() << std::endl;
	}
	// one or more input colletions not found in Event! Aborting...
	if(!colRefData || !colTracks) {
		// streamlog_out(ERROR) << "One or more input collections not found!" << std::endl;
		return;
	}
	//---------------------------------------------------------------------------
	//       Read raw pulses in REF and transform to global coordinates
	//---------------------------------------------------------------------------
	auto local_hits = getRefHits(colRefData);
	auto global_hits = transformRefHits(local_hits);
	auto tracks = getTracksFromCollection(evt, colTracks);
	std::vector<Eigen::Vector3d> aligned;
	auto max_dist = Eigen::Array3d(_cutData.sigmaX, _cutData.sigmaY, 100) * _cutWidthTimesSigma / 2;
	LCCollectionVec* col = nullptr;
	try
	{
		col  = static_cast<LCCollectionVec*> (evt->getCollection(_colTransformedRefData));
	}
	catch(...)
	{
		col = new LCCollectionVec(LCIO::TRACKERHIT);
	}
//	LCCollectionVec* colFilteredTracks = nullptr;
//	try
//	{
//		colFilteredTracks  = static_cast<LCCollectionVec*> (evt->getCollection(_colFilteredTracks));
//	}
//	catch(...)
//	{
//		colFilteredTracks = new LCCollectionVec(LCIO::TRACK);
//	}
	bool eventHasHits = false;
	std::ofstream of;
	if(_debugCsvOutput) {
		of.open(_debugCsvOutputFile, std::ofstream::app);
	}
	std::ofstream csv;
	if(_csvOutputFileEnable) {
		csv.open(_csvOutputFile, std::ofstream::app);
	}
	CellIDEncoder<TrackerHitImpl> idHitEncoder(EUTELESCOPE::HITENCODING, col);
	for(const auto& ghit: global_hits) {
		auto hit = ghit + Eigen::Vector3d(-_cutData.meanX, -_cutData.meanY, 0);	
		for(auto& track: tracks) {
			// extrapolate track onto 2d REF layer
			auto base = track.fitted[0];
			auto dir = track.fitted[2] - track.fitted[0];
			auto t = (hit(2) - base(2)) / dir(2);
			auto hit_extrapolated = base + t*dir;
		//	streamlog_out(MESSAGE) << "HIT " << hit-hit_extrapolated << "\nMAX DIST " << max_dist << std::endl;
			if(((hit-hit_extrapolated).array().abs() > max_dist).any()) {
				// streamlog_out(MESSAGE) << "Discard!" << std::endl;
				continue;
			}
		//	streamlog_out(MESSAGE) << "Push Back" << std::endl;
			eventHasHits = true;
			auto new_hit = new IMPL::TrackerHitImpl();
			/// \todo Much stuff missing(?), see EUTelProcessorHitMaker.cc:517
			double posPtr[3];
			Eigen::Map<Eigen::Vector3d>(posPtr, hit.rows(), hit.cols()) = hit;
			assert(posPtr != nullptr);
			new_hit->setPosition(posPtr);
			idHitEncoder["sensorID"] = _refSensorId;
			idHitEncoder["properties"] = 0;
			idHitEncoder["properties"] = kHitInGlobalCoord;
			idHitEncoder.setCellID(new_hit);
			col->push_back(new_hit);
			if(_debugCsvOutput) {
				of << posPtr[0] << "\t"
				   << posPtr[1] << "\t"
				   << posPtr[2] << "\t"
				   << evt->getEventNumber() << "\t"
				   << evt->getRunNumber() << "\t"
				   << "0\n"; // not a dummy event
			}

			// track and ref hit in line! save track
			if(_csvOutputFileEnable) {
				for(size_t i=0; i<track.fitted.size(); i++) {
					csv << track.fitted[i](0) << "\t"
					    << track.fitted[i](1) << "\t"
					    << track.fitted[i](2) << "\t"
					    << track.fittedSensor[i] << "\t"
					    << evt->getEventNumber() << "\t"
					    << evt->getRunNumber() << "\n";
				}
				csv << posPtr[0] << "\t"
				    << posPtr[1] << "\t"
				    << posPtr[2] << "\t"
				    << _refSensorId << "\t"
				    << evt->getEventNumber() << "\t"
				    << evt->getRunNumber() << "\n\n\n";
			}

			// track and ref hit in line! save track
/*			auto original_track = colTracks->getElementAt(track.trackNumber);
			assert(original_track);
			auto track_cpy = original_track->clone();
			assert(track_cpy);
			assert(original_track != track_cpy); // as long as LCIO does not support clone, no collection for you!
			colFilteredTracks->push_back(track_cpy);*/
		}
	}
	if(_debugCsvOutput) {
		if(eventHasHits) {
			of << "\n\n"; // two empty lines -> new block
		} else {
			of << "0\t0\t0\t"
			   << evt->getEventNumber() << "\t"
			   << evt->getRunNumber() << "\t"
			   << "1\n\n\n"; // dummy event
		}
		of.close();
	}
	if(_csvOutputFileEnable) {
		csv.flush();
		csv.close();
	}
	//evt->addCollection(colFilteredTracks, _colFilteredTracks);
	evt->addCollection(col, _colTransformedRefData); 
}

void RefTransformProcessor::check( LCEvent * evt )
{
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}

void RefTransformProcessor::end()
{
}

std::vector<Eigen::Vector2d> RefTransformProcessor::getRefHits(LCCollection* collection)
{
	std::vector<Eigen::Vector2d> hits;
	try {
		CellIDDecoder<TrackerDataImpl> cellDecoder(collection);
		assert(collection->getNumberOfElements() == 1);
		auto data = dynamic_cast<TrackerDataImpl*>(collection->getElementAt(0));
		auto type = static_cast<SparsePixelType>(static_cast<int>(cellDecoder(data)["sparsePixelType"]));
		assert(type == kEUTelGenericSparsePixel);
		auto sparseData = std::make_unique<EUTelTrackerDataInterfacerImpl<EUTelGenericSparsePixel>>(data);
		auto sparsePixel = std::make_unique<EUTelGenericSparsePixel>();
		for(size_t i=0; i < sparseData->size(); i++) {
			sparseData->getSparsePixelAt(i, sparsePixel.get());
			hits.push_back(Eigen::Vector2d{sparsePixel->getXCoord(), sparsePixel->getYCoord()});
		}
	} catch(const std::exception& e) {
		streamlog_out(WARNING) << "getRefHits(): " << e.what() << std::endl;
	}
	return hits;
}

std::vector<Eigen::Vector3d> RefTransformProcessor::transformRefHits(std::vector<Eigen::Vector2d> hits)
{
	std::vector<Eigen::Vector3d> transformed;
	// "alias" to make code more readable
	auto layers = _siPlanesLayerLayout;
	int refIdx = -1;
	for(int i=0; i<layers->getNLayers(); i++) {
		auto id = layers->getID(i);
		if(id == _refSensorId) {
			refIdx = i;
			break;
		}
	}
	if(refIdx == -1) {
		streamlog_out(ERROR4) << "Did not find REF in GEAR file with sensor ID "
				      << _refSensorId << std::endl;
		exit(-1);
	}
	Eigen::Vector3d layer_offset(
		layers->getLayerPositionX(refIdx),
		layers->getLayerPositionY(refIdx),
		layers->getLayerPositionZ(refIdx));
	/// \todo these are usually zero in our GEAR files, so we ignore them for now...
	auto layer_alpha = layers->getLayerRotationZY(refIdx); // around X
	auto layer_beta = layers->getLayerRotationZX(refIdx); // around Y
	auto layer_gamma = layers->getLayerRotationXY(refIdx); // around Z
	Eigen::Matrix3d layer_rot(Eigen::Matrix3d::Identity());

	Eigen::Vector3d sensitive_offset(
		layers->getSensitivePositionX(refIdx),
		layers->getSensitivePositionY(refIdx),
		layers->getSensitivePositionZ(refIdx));
	Eigen::Matrix2d sensitive_rot;
	sensitive_rot << layers->getSensitiveRotation1(refIdx),
			 layers->getSensitiveRotation2(refIdx),
			 layers->getSensitiveRotation3(refIdx),
			 layers->getSensitiveRotation4(refIdx);
	Eigen::Array2d sensitive_size(
		layers->getSensitiveSizeX(refIdx),
		layers->getSensitiveSizeY(refIdx));
	Eigen::Array2i sensitive_npix(
		layers->getSensitiveNpixelX(refIdx),
		layers->getSensitiveNpixelY(refIdx));
	auto sensitive_pitch = sensitive_size / sensitive_npix.cast<double>();
	for(const auto& hit: hits) {
		auto l_hit = sensitive_rot * (hit.array()*sensitive_pitch - sensitive_size/2).matrix();
		Eigen::Vector3d l_hit2 = {l_hit[0], l_hit[1], 0};
		l_hit2 += sensitive_offset;
		if(_swapRefAxis) {
			double x = l_hit2(0);
			double y = l_hit2(1);
			l_hit2(1) = x;
			l_hit2(0) = y;
		}
		if(_flipXCoordinate) l_hit2(0) *= -1;
		if(_flipYCoordinate) l_hit2(1) *= -1;
		transformed.push_back(l_hit2);
	}
	return transformed;
}

void RefTransformProcessor::bookHistos()
{
#if defined(USE_AIDA) || defined(MARLIN_USE_AIDA)
#endif
}

std::vector<RefTransformProcessor::track_t> RefTransformProcessor::getTracksFromCollection(LCEvent* evt, LCCollection* col)
{
	std::vector<track_t> tracks;
	for(int i=0; i < col->getNumberOfElements(); i++) {
		auto track = dynamic_cast<EVENT::Track*>(col->getElementAt(i));
		assert(track != nullptr);
		auto decoder = CellIDDecoder<TrackerHit>(EUTELESCOPE::HITENCODING);
		track_t new_track;
		new_track.eventNumber = evt->getEventNumber();
		new_track.trackNumber = i;
		for(auto hit: track->getTrackerHits()) {
			auto pos = hit->getPosition();
			Eigen::Vector3d posVec(pos[0], pos[1], pos[2]);
			auto properties = decoder(hit)["properties"];
			auto sensor = decoder(hit)["sensorID"];
			bool fitted = (properties&kFittedHit) > 0;
			if(fitted) {
				new_track.fitted.push_back(posVec);
				new_track.fittedSensor.push_back(sensor);
			} else {
				new_track.raw.push_back(posVec);
				new_track.rawSensor.push_back(sensor);
			}	
		}
		tracks.push_back(new_track);
	}
	return tracks;
}

